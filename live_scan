import cv2
import os
import numpy as np
import tkinter as tk
from tkinter import filedialog, messagebox
from tkinter import ttk

# Elementų šablonų keliai
element_templates = {
    'resistor': 'C:/Users/guest08/Documents/GitHub/BIP-Estonia-Project/Symbols/resistor.png',
    'GenericTwoWayValve': 'C:/Users/guest08/Documents/GitHub/BIP-Estonia-Project/Symbols/GenericTwoWayValve.png',
    'GenericActuator': 'C:/Users/guest08/Documents/GitHub/BIP-Estonia-Project/Symbols/GenericActuator.png'
}

# Funkcija ignoruoti baltas sritis ir paryškinti kontūrus
def preprocess_image(image):
    if len(image.shape) == 3:  # Tikriname, ar vaizdas turi 3 kanalus (spalvotas vaizdas)
        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    else:
        gray = image  # Jei jau yra pilkų atspalvių, paliekame kaip yra

    # Ignoruoti baltą spalvą
    _, thresh = cv2.threshold(gray, 240, 255, cv2.THRESH_BINARY_INV)

    # Naudoti kontūrų išryškinimą
    edged = cv2.Canny(thresh, 50, 200)
    return edged

# Funkcija, skirta aptikti simbolius pagal šabloną (template matching)
def detect_symbols_from_image(image):
    detected_symbols = []
    processed_image = preprocess_image(image)

    image_height, image_width = processed_image.shape[:2]

    for element_name, template_path in element_templates.items():
        if os.path.exists(template_path):
            template = cv2.imread(template_path, 0)  # Nuskaitome šabloną pilku atspalviu
            template = preprocess_image(template)
            template_height, template_width = template.shape[:2]

            best_match_value = 0
            best_match_location = None
            best_template_scale = None

            # Pradėkime su mastelio keitimu (scale) nuo 0.5 iki 1.5
            for scale in np.linspace(0.5, 1.5, 20):
                resized_template = cv2.resize(template, None, fx=scale, fy=scale)

                if resized_template.shape[0] > image_height or resized_template.shape[1] > image_width:
                    continue

                result = cv2.matchTemplate(processed_image, resized_template, cv2.TM_CCOEFF_NORMED)
                min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)

                # Patikriname, ar ši vieta yra geresnė už ankstesnę
                if max_val > best_match_value:
                    best_match_value = max_val
                    best_match_location = max_loc
                    best_template_scale = scale

            if best_match_value >= 0.55:  # Slenkstis nuleistas iki 0.55
                # Pažymime aptiktą simbolį
                detected_symbols.append({
                    'symbol': element_name,
                    'coordinates': (best_match_location[0], best_match_location[1],
                                    int(template_width * best_template_scale),
                                    int(template_height * best_template_scale))
                })

                # Pažymėti aptiktą simbolį raudonu kvadratu
                top_left = best_match_location
                bottom_right = (top_left[0] + int(template_width * best_template_scale),
                                top_left[1] + int(template_height * best_template_scale))

                cv2.putText(image, element_name, (top_left[0], top_left[1] - 10),
                            cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 0, 255), 2)
                cv2.rectangle(image, top_left, bottom_right, (0, 0, 255), 3)

    return detected_symbols

# Funkcija, skirta apdoroti įkeltą nuotrauką ir aptikti simbolius
def upload_image():
    file_path = filedialog.askopenfilename(filetypes=[("Image files", "*.png;*.jpg;*.jpeg")])
    if file_path:
        image = cv2.imread(file_path)
        detected_symbols = detect_symbols_from_image(image)

        if detected_symbols:
            cv2.imshow('Detected Symbols in Photo', image)
            print(f"Detected Symbols: {detected_symbols}")
        else:
            messagebox.showinfo("Information", "No symbols detected!")

# Funkcija, skirta skenuoti su kamera ir leisti fotografuoti (S mygtukas)
def scan_image():
    cap = cv2.VideoCapture(0)

    if not cap.isOpened():
        messagebox.showerror("Error", "Unable to open camera.")
        return

    frame_count = 0

    while True:
        ret, frame = cap.read()
        if not ret:
            print("Failed to read frame.")
            break

        detected_symbols = detect_symbols_from_image(frame)

        # Rodyti vaizdą su aptiktais simboliais
        cv2.imshow('Live Scan', frame)

        key = cv2.waitKey(1) & 0xFF

        # Išsaugoti vaizdą paspaudus "S"
        if key == ord('s'):
            frame_count += 1
            image_path = f'screenshot_{frame_count}.png'
            cv2.imwrite(image_path, frame)
            print(f"Image saved as: {image_path}")

        # Išeiti iš ciklo paspaudus "q"
        if key == ord('q'):
            break

    cap.release()
    cv2.destroyAllWindows()

# Patobulinta GUI sąsaja su Tkinter ir ttk stiliumi, bei keybinds informacija
def main():
    root = tk.Tk()
    root.title("Symbol Recognition")
    root.geometry("500x400")
    root.configure(bg="#f0f0f0")

    # Pridėti stilių
    style = ttk.Style()
    style.configure('TButton', font=('Helvetica', 12), padding=10)
    style.configure('TLabel', font=('Helvetica', 14), padding=10)

    # Pavadinimas
    title_label = ttk.Label(root, text="Symbol Recognition System", background="#f0f0f0")
    title_label.pack(pady=20)

    # "Upload Photo" mygtukas
    upload_button = ttk.Button(root, text="Upload Circuit Diagram", command=upload_image)
    upload_button.pack(pady=10)

    # "Scan" mygtukas
    scan_button = ttk.Button(root, text="Scan with Camera", command=scan_image)
    scan_button.pack(pady=10)

    # Keybinds informacija
    keybinds_label = ttk.Label(root, text="Keybinds:\nQ - Close Camera\nS - Take Screenshot\n", background="#f0f0f0")
    keybinds_label.pack(pady=20)

    # Užbaigti GUI loop
    root.mainloop()

if __name__ == "__main__":
    main()
